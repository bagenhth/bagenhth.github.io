<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Spring事务回滚与UnexpectedRollbackException · Geek</title><meta name="description" content="Spring事务回滚与UnexpectedRollbackException - Bruce Lee"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://geek.com/atom.xml" title="Geek"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/bagenhth" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Spring事务回滚与UnexpectedRollbackException</h1><div class="post-info">2017年11月26日</div><div class="post-content"><p>　　最近工作中碰到了一个关于事务回滚的异常 —— <strong>UnexpectedRollbackException</strong>，稍微研究了一下，它和Spring的异常回滚机制以及事务嵌套有关系，这里记录一下，以免忘记。<br>　　<a id="more"></a><br>　　[TOC]</p>
<h2 id="1-Java异常框架"><a href="#1-Java异常框架" class="headerlink" title="1) Java异常框架"></a>1) Java异常框架</h2><p>　　进入正题之前，先铺垫一点Java异常处理的知识。<br>　　<img src="http://p010le52b.bkt.clouddn.com/1211217-20171026090946629-863472483.png" alt="Java异常框架"><br>　　Java的异常处理框架，是Java语言健壮性的一个体现。我们平常提到的异常，其实是Java异常处理框架中的Exception；<strong>Throwable</strong>是所有异常和错误的超类，<strong>Error</strong>和<strong>Exception</strong>是Throwable的两个子类，分别代表错误和异常。<br>错误代表程序运行中的一种不可恢复的错误状态，可能和程序有关，也可能与外部因素有关，出现这样的情况时，JVM一般会选择终止线程；异常代表程序运行中的一种错误状态，通常这种状态是由于代码组织的不完备性或者逻辑错误引起的，是一种可以恢复的状态，程序中应该尽量去处理这些异常。<br>　　异常又可以分为运行时异常和非运行时异常，运行时异常（RuntimeException）也叫受检异常（Checked Exception），非运行时异常也叫非受检异常（Unchecked Exception）。运行时异常都是RuntimeException及其子类异常，这一类异常发生时可以选择处理，也可以选择不处理，因此称为非受检异常，NullPointerException、IndexOutofBoundsException等属于此类异常；而非运行时异常是除了RuntimeException以外的异常，类型上都属于Exception的子类，java源代码编译时会检查这一类异常，如果不进行处理程序就无法编译通过，因此称为受检异常，IOException、SQLException等都属于此列。</p>
<h2 id="2-Spring事务回滚"><a href="#2-Spring事务回滚" class="headerlink" title="2) Spring事务回滚"></a>2) Spring事务回滚</h2><p>　　Spring框架对事务回滚做了限制，被Spring事务管理的方法，需要抛出非受检异常（RuntimeException或者它的子类），才能自动进行回滚操作。<em>注意，使用try-catch捕获异常会导致事务不会滚，需要向上一层再次抛出一个异常，这样才能使用Spring的事务自动回滚机制</em><br>　　在Spring的事务管理环境下，使用Unckecked Exception可以极大地简化异常的处理，只需要在事务层声明可能抛出的异常（这里的异常可以是自定义的Unckecked Exception体系），在所有的中间层都只是需要简单throws即可，不需要捕捉和处理，直接到最高层，比如UI层再进行异常的捕捉和处理（在Spring MVC的环境下，可能在Controller层使用@ControllAdvice注解以及@ExceptionHadler注解进行全局异常捕获），通常的做法是service类前加上@Transactional注解，声明这个service所有方法需要事务管理，这样每一个业务方法开始时都会打开一个事务。</p>
<h2 id="3-UnexpectedRollbackException"><a href="#3-UnexpectedRollbackException" class="headerlink" title="3) UnexpectedRollbackException"></a>3) UnexpectedRollbackException</h2><p>　　铺垫结束，进入本文标题的例子，有两个Service，假定为ServiceA和ServiceB，两个Service都使用@Transactional注解，其中ServiceA中methodA会调用ServiceB中的methodB，而methodB可能抛出异常，伪代码描述如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ServiceA &#123;</div><div class="line"></div><div class="line">    methodA() &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            methodB();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">            ....</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　使用如上的处理方式，会在运行期间抛出<strong>UnexpectedRollbackException</strong>异常，原因在于ServiceB使用@Transactional注解标记为异常回滚中的，而methodB在调用过程中出现异常后被捕获，使得事务没有被回滚，仅仅只是标记器状态为需要回滚，methodA正常执行，在commit时Spring会判断回滚标志，此时检测到回滚标志，于是抛出<strong>UnexpectedRollbackException</strong>，并回滚事务（UnexpectedRollbackException没有被处理，而且也不是符合业务需求的回滚操作）。<br>　　<strong>针对以上情景，目前采用的处理方案是在methodA上使用@Transaction(rollabckFor={Exception.class})注解，使得对于受检异常，也执行回滚操作，也就是说在调用methodB时捕获异常的话也执行回滚操作，这样就可以避免事务嵌套时由于异常被捕获而导致的</strong>UnexpectedRollbackException<strong>。</strong></p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/08/24/Spring-In-Action-JPA/" class="next">NEXT</a></div><div class="copyright"><p>© 2016 - 2017 <a href="http://geek.com">Bruce Lee</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>